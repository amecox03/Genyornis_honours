---
title: "Genyornis_regressions"
author: "Amelia Cox, Vera Weisbecker"
date: "2024-04-29"
output: html_document
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, message=FALSE, results='hide' )
```

```{r setup of libraries}
#this sets the directory to the source directory without having to manually click your way there
library(rstudioapi) # Safely Access the RStudio API
setwd(dirname(getActiveDocumentContext()$path))

#make sure you delete all empty columns/rows by hitting "delete" in excel
data<-read.csv(file = "../Data/Raw/honours_hindlimbs.csv")

```

#Titles also often go here - up to you :-)
#Read up on Reduced Major Axis (RMA) regression which allows for both variable being responses (rather than y being response, x being predictor - but don't get too hung up about this now :-))
```{r Amelias first analyses}
#just a summary of the data
summary(data)


#run a linear model: y is on left, x is on right
reg1 <- lm(log(data$fM.L) ~ log(data$tbM.L))

#here's how to get a summary output
summary(reg1)

#plotting like this NOW HAS x on left, y on right
plot(log(data$fM.L) ~ log(data$tbM.L))
abline(reg1)


```

```{r make dataset w/o Genyornis}

data_noG <- data[-c(77:82),]

#run a linear model: y is on left, x is on right
NoG <- lm(log(data_noG$fM.L) ~ log(data_noG$tbM.L))

#here's how to get a summary output
summary(NoG)


```

#Here is the fixed Prediction interval code. You need to run this on the dataset without Genyornis - use the above. I jsut ran out of time but I think YOU CAN DO IT :-)
```{r plotting}
#Here we're log transforming first, because otherwise things don't work. 

data_plot <- cbind (data[,1:2], log (data[,3:15]))

#Also here setting up a vector of colours you can use to highlight _Genyornis_
#make a vector of just pink
colours <- rep("hotpink", nrow(data_plot))
#make a vector where any species name that has Genyornis is assigned purple
colours[which(data_plot$species == "Genyornis newtoni")] <- "purple"

#getting a model for predicting CIs
model <- lm(fM.L ~ tbM.L, data=data_plot)
summary(model)

#For the interval estimate to work, we need to find the smallest and largest values of x. All this is in https://stackoverflow.com/questions/46459620/plotting-a-95-confidence-interval-for-a-lm-object

#But X in this case has NAs so we're here finding the lowest non-NA value by sorting from smallest to largest and taking the first value
min_x <- sort(data_plot$tbM.L)[1]
max_x <- sort(data_plot$tbM.L, decreasing = TRUE)[1]

#make dummy sequence of x for intervals. 
newx <- seq(min_x-1,max_x+1,by = 0.05 )

#plot confidence intervals

#This only works if the data are already logged. Not my preference but hey.
conf_interval <- predict(model, newdata=data.frame(tbM.L = newx), interval="prediction",    level = 0.95)



plot(data_plot$fM.L ~ data_plot$tbM.L, 
     xlim=c(1.6,4.5), 
     ylim=c(1.7,4.5), 
     pch=19, col=colours); abline(model, col="black" )

lines(newx, conf_interval[,2], col="blue", lty=2)
lines(newx, conf_interval[,3], col="blue", lty=2)

#fill in area between regression line and confidence interval - very pretty but then you have to re-plot the points
polygon(c(rev(newx), newx), c(rev(conf_interval[ ,3]), conf_interval[ ,2]), col = 'grey', border = NA)



points(data_plot$fM.L ~ data_plot$tbM.L, 
     
     pch=19, col=colours); abline(model, col="black" )
lines(newx, conf_interval[,2], col="blue", lty=2)
lines(newx, conf_interval[,3], col="blue", lty=2)





#add row names to your plot
#text(log(data$fM.L) ~ log(data$tbM.L), labels=data$species )


```

#The default is 9%% confidence interval. These intervals seem very narrow! But the below runs an example that shows the same. But we are interested in the prediction intervals, anyway.

```{r 95% confidence interval basic script}

#make this example reproducible
set.seed(0)

#create dataset
x <- rnorm(100)
y <- x*2 + rnorm(100)
df <- data.frame(x = x, y = y)

#fit linear regression model
model <- lm(y ~ x, data = df) 

#get predicted y values using regression equation
newx <- seq(min(df$x), max(df$x), length.out=100)
preds <- predict(model, newdata = data.frame(x=newx), interval = 'confidence')

#create plot of x vs. y
plot(y ~ x, data = df)

#fill in area between regression line and confidence interval
polygon(c(rev(newx), newx), c(rev(preds[ ,3]), preds[ ,2]), col = 'grey', border = NA)

#add fitted regression line
abline(model)

#add dashed lines for confidence bands
lines(newx, preds[ ,3], lty = 'dashed', col = 'blue')
lines(newx, preds[ ,2], lty = 'dashed', col = 'blue')


```



```{r length vs width f}

#linear model of the length vs width of the femur excluding Genyornis
noGFLW <- lm(log(data_noG$fL) ~ log(data_noG$fM.L))

#summary of the linear model of the length vs width of the femur excluding Genyornis
summary(noGFLW)

#plot of the length vs width of the femur
plot(log(data$fL) ~ log(data$fM.L), pch=19, col=colours); abline(noGFLW, col="black")






#getting a model for predicting CIs
modelFLW <- lm(fL ~ fM.L, data=data_plot)
summary(modelFLW)

#For the interval estimate to work, we need to find the smallest and largest values of x. All this is in https://stackoverflow.com/questions/46459620/plotting-a-95-confidence-interval-for-a-lm-object

#But X in this case has NAs so we're here finding the lowest non-NA value by sorting from smallest to largest and taking the first value
min_xW <- sort(data_plot$fM.L)[1]
max_xW <- sort(data_plot$fM.L, decreasing = TRUE)[1]

#make dummy sequence of x for intervals. 
newxW <- seq(min_xW-1,max_xW+1,by = 0.05 )

#plot confidence intervals

#This only works if the data are already logged. Not my preference but hey.
conf_intervalW <- predict(modelFLW, newdata=data.frame(fM.L = newxW), interval="prediction",    level = 0.95)



plot(data_plot$fL ~ data_plot$fM.L, 
     pch=19, col=colours); abline(modelFLW, col="black" )

lines(newxW, conf_intervalW [,2], col="blue", lty=2)
lines(newxW, conf_intervalW [,3], col="blue", lty=2)

#fill in area between regression line and confidence interval - very pretty but then you have to re-plot the points
polygon(c(rev(newxW), newxW), c(rev(conf_intervalW [ ,3]), conf_intervalW[ ,2]), col = 'grey', border = NA)



points(data_plot$fL ~ data_plot$fM.L, 
     
     pch=19, col=colours); abline(modelFLW, col="black" )
lines(newxW, conf_intervalW [,2], col="blue", lty=2)
lines(newxW, conf_intervalW [,3], col="blue", lty=2)





#text to data points
#text(log(data$fL) ~ log(data$fM.L), label=data$species)

```




```{r plotting the femur and tibia length}



#linear model of the length of the femur vs the tibiotarsus excluding Genyornis
noGFTL <- lm(log(data_noG$fL) ~ log(data_noG$tbL))


#summary of the linear model of the length vs width of the femur excluding Genyornis
summary(noGFTL)

#plot of the length vs width of the femur
plot(log(data$fL) ~ log(data$tbL), pch=19, col=colours)
     abline(noGFTL, col="black")




#getting a model for predicting CIs
modelFTL <- lm(fL ~ tbL, data=data_plot)
summary(modelFTL)

#For the interval estimate to work, we need to find the smallest and largest values of x. All this is in https://stackoverflow.com/questions/46459620/plotting-a-95-confidence-interval-for-a-lm-object

#But X in this case has NAs so we're here finding the lowest non-NA value by sorting from smallest to largest and taking the first value
min_xL <- sort(data_plot$tbL)[1]
max_xL <- sort(data_plot$tbL, decreasing = TRUE)[1]

#make dummy sequence of x for intervals. 
newxL <- seq(min_xL-1,max_xL+1,by = 0.05 )

#plot confidence intervals

#This only works if the data are already logged. Not my preference but hey.
conf_intervalL <- predict(modelFTL, newdata=data.frame(tbL = newxL), interval="prediction",    level = 0.95)



plot(data_plot$fL ~ data_plot$tbL, 
     pch=19, col=colours); abline(modelFTL, col="black" )

lines(newxL, conf_intervalL [,2], col="blue", lty=2)
lines(newxL, conf_intervalL [,3], col="blue", lty=2)

#text((data_plot$fL ~ data_plot$tbL), label=data$species)


#fill in area between regression line and confidence interval - very pretty but then you have to re-plot the points
polygon(c(rev(newxL), newxL), c(rev(conf_intervalL [ ,3]), conf_intervalL[ ,2]), col = 'grey', border = NA)



points(data_plot$fL ~ data_plot$tbL, 
     
     pch=19, col=colours); abline(modelFTL, col="black" )
lines(newxL, conf_intervalL [,2], col="blue", lty=2)
lines(newxL, conf_intervalL [,3], col="blue", lty=2)


```





```{r graph of proportion of hindlimb in species}










```





```{r aepyornithid hindlimb data from Hansford & Turvey 2018}

data_aepyorn <-read.csv(file = "../Data/Raw/Aepyronithid_hindlimb_measurements.csv", header = TRUE, sep = ",", colClasses = c("character","character","character","character","character","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric"))



data_aepyorn <- read.csv(file = "../Data/Raw/Aepyronithid_hindlimb_measurements.csv", header = TRUE, sep = ",", colClasses = c("character","character","character","character","character","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric"), stringsAsFactors = FALSE)


data_aepyorn <- read.csv(file = "../Data/Raw/Aepyronithid_hindlimb_measurements.csv", header = TRUE, sep = ",", colClasses = "numeric")


# Example data frame
data <- data.frame(
  Name = c("John", "Jane", "John", "Alice", "Bob"),
  Score1 = c(80, 75, 85, 90, 95),
  Score2 = c(70, 65, 75, 80, 85)
)

aep.hil <- c("hildebrandti")

as.numeric()

# Names for which you want to calculate means
target_names <- c("John", "Bob")

# Step 1: Subset rows with target names
subset_data <- data[data$Name %in% target_names, ]

subset_data <- data_aepyorn[data_aepyorn$genus %in% aep.hil,]

# Step 2: Calculate mean for each column in the subset
means <- colMeans(subset_data[, c("Score1", "Score2")])

aep.hilm <- colMeans(subset_date[, c("fL", "fPW", "fDW", "fCr.Ca","fM.L","tbL","tbPW", "tbDW","tbCr.Ca","tbM.L","tmtL","tmtD.P","tmtM.L")])

# Step 3: Print or use the means as needed
print(means)



# Assuming subset_data is correctly defined
subset_data <- data[data$Name %in% target_names, ]

# Columns for which you want to calculate means
columns_of_interest <- c("fL", "fPW", "fDW", "fCr.Ca", "fM.L", "tbL", 
                         "tbPW", "tbDW", "tbCr.Ca", "tbM.L", "tmtL", 
                         "tmtD.P", "tmtM.L")

# Calculate mean for each column
aep.hilm <- colMeans(subset_data[, columns_of_interest])

# Print or use the means as needed
print(aep.hilm)

```












