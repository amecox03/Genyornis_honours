knitr::opts_chunk$set(echo=FALSE, message=FALSE, results='hide' )
#this sets the directory to the source directory without having to manually click your way there
library(rstudioapi) # Safely Access the RStudio API
setwd(dirname(getActiveDocumentContext()$path))
#make sure you delete all empty columns/rows by hitting "delete" in excel
data<-read.csv(file = "../Data/Raw/honours_hindlimbs.csv")
#data that includes Dinornithiformes, Dromornis stirtoni, & Illbandornis sp.
data2 <- read.csv (file = "../Data/Raw/honours_hindlimb_updated.csv")
library(tidyverse)
data_aepyorn <- read.csv(file = "../Data/Raw/Aepyronithid_hindlimb_measurements.csv")
#some numeric columns import as non-numeric, as.numeric changes these columns into numeric columns
data_aepyorn[, 5] <- as.numeric(data_aepyorn [,5])
data_aepyorn[,10] <- as.numeric (data_aepyorn[,10])
data_aepyorn[,12] <- as.numeric (data_aepyorn[,12])
data_aepyorn[,15] <- as.numeric (data_aepyorn[,15])
#species name for which mean is to be calculated for A. hildebrandti
aep.hil <- c("hildebrandti")
#a subset data frame for the rows that i want to target for A. hildebrandti
subset_data <- data_aepyorn[data_aepyorn$genus %in% aep.hil,]
#calculate the means of Aepyornis hildebrandti
aep.hilm <- colMeans(subset_data[, c("fL", "fPW", "fDW", "fCr.Ca","fM.L","tbL","tbPW", "tbDW","tbCr.Ca","tbM.L","tmtL","tmtD.P","tmtM.L")], na.rm = TRUE)
#printing the means for Aepyornis hildebrandti
print(aep.hilm)
#species name for which mean is to be calculated for A. maximus
aep.max <- c("maximus")
#a subset data frame for the rows that i want to target for A. maximus
subset_datam <- data_aepyorn[data_aepyorn$genus %in% aep.max,]
#calculate the means of Aepyornis maximus
aep.maxi <- colMeans(subset_datam[, c("fL", "fPW", "fDW", "fCr.Ca","fM.L","tbL","tbPW", "tbDW","tbCr.Ca","tbM.L","tmtL","tmtD.P","tmtM.L")], na.rm = TRUE)
#printing the means for Aepyornis maximus
print(aep.maxi)
#species name for which mean is to be calculated for M. modestus
mul.mod <- c("modestus")
#a subset data frame for the rows that i want to target for M. modestus
subset_datamm <- data_aepyorn[data_aepyorn$genus %in% mul.mod,]
#calculate the means of M. modestus
mul.mode <- colMeans(subset_datamm[, c("fL", "fPW", "fDW", "fCr.Ca","fM.L","tbL","tbPW", "tbDW","tbCr.Ca","tbM.L","tmtL","tmtD.P","tmtM.L")], na.rm = TRUE)
#printing the means for M. modestus
print(mul.mode)
#just a summary of the data
summary(data)
#run a linear model: y is on left, x is on right
reg1 <- lm(log(data$fM.L) ~ log(data$tbM.L))
#here's how to get a summary output
summary(reg1)
#plotting like this NOW HAS x on left, y on right
plot(log(data$fM.L) ~ log(data$tbM.L)); abline(reg1)
data_noG <- data[-c(77:82),]
#run a linear model: y is on left, x is on right
NoG <- lm(log(data_noG$fM.L) ~ log(data_noG$tbM.L))
#here's how to get a summary output
summary(NoG)
data2_noD <- data2[-c(124:132),]
#linear model of the femur medial lateral width against tibia medial lateral width, w/o dromornithids
noD_widths <- lm(log(data2_noD$fM.L)~log(data2_noD$tbM.L))
#linear model of the femur medial lateral width against tibia medial lateral width w/ dromorntiids
wD_widths <- lm(log(data2$fM.L)~log(data2$tbM.L))
#summary of the two linear models
summary(noD_widths)
summary(wD_widths)
#Here we're log transforming first, because otherwise things don't work.
data_plot <- cbind (data2[,1:3], log (data2[,4:16]))
#Also here setting up a vector of colours you can use to highlight _Genyornis_
#make a vector of just pink
colours <- rep("hotpink", nrow(data_plot))
#make a vector where any species name that has Genyornis is assigned purple
colours[which(data_plot$species == "Genyornis newtoni")] <- "#33cc33"
colours[which(data_plot$species == "Illbandornis lawsoni")] <- "#196619"
colours[which(data_plot$species == "Illbandornis woodburnei")] <- "green"
colours[which(data_plot$species == "Aepyornis maximus")] <- "#ff0000"
colours[which(data_plot$species == "Mullerornis modestus")] <- "#cc0000"
colours[which(data_plot$species == "Dinornis robustus")] <- "#ff6600"
colours[which(data_plot$species == "Dinornis novaezealandiae")] <- "#b34700"
colours[which(data_plot$species == "Pachyornis elephantopus")] <- "#ffc299"
colours[which(data_plot$species == "Struthio camelus")] <- "#191966"
colours[which(data_plot$species == "Dromaius novaehollandiae")] <- "#3366ff"
colours[which(data_plot$species == "Casuarius casuarius")] <- "#3333cc"
colours[which(data_plot$species == "Leipoa ocellata")] <- "#9900cc"
colours[which(data_plot$species == "Alectura lathami")] <- "#800080"
colours[which(data_plot$species == "Cereopsis novaehollandiae")] <- "#ff00ff"
colours[which(data_plot$species == "Anseranas semipalmata")] <- "#ff0055"
#getting a model for predicting CIs
model1 <- lm(fM.L ~ tbM.L, data=data_plot)
summary(model1)
#For the interval estimate to work, we need to find the smallest and largest values of x. All this is in https://stackoverflow.com/questions/46459620/plotting-a-95-confidence-interval-for-a-lm-object
#But X in this case has NAs so we're here finding the lowest non-NA value by sorting from smallest to largest and taking the first value
min_x <- sort(data_plot$tbM.L)[1]
max_x <- sort(data_plot$tbM.L, decreasing = TRUE)[1]
#make dummy sequence of x for intervals.
newx <- seq(min_x-1,max_x+1,by = 0.05 )
#plot confidence intervals
#This only works if the data are already logged. Not my preference but hey.
conf_interval <- predict(model1, newdata=data.frame(tbM.L = newx), interval="prediction", level = 0.95)
plot(data_plot$fM.L ~ data_plot$tbM.L,
xlim=c(1.6,4.5),
ylim=c(1.7,4.5),
pch=19, col=colours); abline(noD_widths, col="black" )
lines(newx, conf_interval[,2], col="blue", lty=2)
lines(newx, conf_interval[,3], col="blue", lty=2)
#fill in area between regression line and confidence interval - very pretty but then you have to re-plot the points
polygon(c(rev(newx), newx), c(rev(conf_interval[ ,3]), conf_interval[ ,2]), density = 25,col = 'grey', border = NA)
points(data_plot$fM.L ~ data_plot$tbM.L,
pch=19, col=colours); abline(noD_widths, col="black" )
lines(newx, conf_interval[,2], col="blue", lty=2)
lines(newx, conf_interval[,3], col="blue", lty=2)
#add row names to your plot
#text(data_plot$fM.L ~ data_plot$tbM.L, labels=data_plot$species )
#make this example reproducible
set.seed(0)
#create dataset
x <- rnorm(100)
y <- x*2 + rnorm(100)
df <- data.frame(x = x, y = y)
#fit linear regression model
model <- lm(y ~ x, data = df)
#get predicted y values using regression equation
newx <- seq(min(df$x), max(df$x), length.out=100)
preds <- predict(model, newdata = data.frame(x=newx), interval = 'confidence')
#create plot of x vs. y
plot(y ~ x, data = df)
#fill in area between regression line and confidence interval
polygon(c(rev(newx), newx), c(rev(preds[ ,3]), preds[ ,2]), col = 'grey', border = NA)
#add fitted regression line
abline(model)
#add dashed lines for confidence bands
lines(newx, preds[ ,3], lty = 'dashed', col = 'blue')
lines(newx, preds[ ,2], lty = 'dashed', col = 'blue')
#Here we're log transforming first, because otherwise things don't work.
data_plot2 <- cbind (data2[,1:3], log (data2[,4:16]))
datanoD_plot <- cbind (data2_noD[,1:3], log (data2_noD[,4:16]))
#Also here setting up a vector of colours you can use to highlight _Genyornis_
#make a vector of just pink
colours <- rep("hotpink",nrow(data_plot2))
#make a vector where any species name that has Genyornis is assigned purple
colours[which(data_plot2$species == "Genyornis newtoni")] <- "#33cc33"
colours[which(data_plot2$species == "Illbandornis lawsoni")] <- "#196619"
colours[which(data_plot2$species == "Illbandornis woodburnei")] <- "green"
colours[which(data_plot2$species == "Aepyornis maximus")] <- "#ff0000"
colours[which(data_plot2$species == "Mullerornis modestus")] <- "#cc0000"
colours[which(data_plot2$species == "Dinornis robustus")] <- "#ff6600"
colours[which(data_plot2$species == "Dinornis novaezealandiae")] <- "#b34700"
colours[which(data_plot2$species == "Pachyornis elephantopus")] <- "#ffc299"
colours[which(data_plot2$species == "Struthio camelus")] <- "#191966"
colours[which(data_plot2$species == "Dromaius novaehollandiae")] <- "#3366ff"
colours[which(data_plot2$species == "Casuarius casuarius")] <- "#3333cc"
colours[which(data_plot2$species == "Leipoa ocellata")] <- "#9900cc"
colours[which(data_plot2$species == "Alectura lathami")] <- "#800080"
colours[which(data_plot2$species == "Cereopsis novaehollandiae")] <- "#ff00ff"
colours[which(data_plot2$species == "Anseranas semipalmata")] <- "#ff0055"
#getting a model for predicting CIs
model2 <- lm(fM.L ~ tbM.L, data=data_plot2)
summary(model2)
#For the interval estimate to work, we need to find the smallest and largest values of x. All this is in https://stackoverflow.com/questions/46459620/plotting-a-95-confidence-interval-for-a-lm-object
#But X in this case has NAs so we're here finding the lowest non-NA value by sorting from smallest to largest and taking the first value
min_x <- sort(data_plot$tbM.L)[1]
max_x <- sort(data_plot$tbM.L, decreasing = TRUE)[1]
#make dummy sequence of x for intervals.
newx <- seq(min_x-1,max_x+1,by = 0.05 )
#plot confidence intervals
#This only works if the data are already logged. Not my preference but hey.
conf_interval <- predict(model2, newdata=data.frame(tbM.L = newx), interval="prediction",    level = 0.95)
plot(data_plot$fM.L ~ data_plot$tbM.L,
xlim=c(1.6,4.5),
ylim=c(1.7,4.5),
pch=19, col=colours); abline(noD_widths, col="black" )
lines(newx, conf_interval[,2], col="blue", lty=2)
lines(newx, conf_interval[,3], col="blue", lty=2)
#fill in area between regression line and confidence interval - very pretty but then you have to re-plot the points
polygon(c(rev(newx), newx), c(rev(conf_interval[ ,3]), conf_interval[ ,2]), density = 25, col = 'grey', border = NA)
points(data_plot$fM.L ~ data_plot$tbM.L,
pch=19, col=colours); abline(noD_widths, col="black" )
lines(newx, conf_interval[,2], col="blue", lty=2)
lines(newx, conf_interval[,3], col="blue", lty=2)
#add row names to your plot
#text(log(data$fM.L) ~ log(data$tbM.L), labels=data$species )
#make a data set with extant ratites
ratite <- data2[c(5:25),]
#make a data set with extinct large birds (ratites + dromorntithids)
extinct <- data2[c(77:132),]
#combine the 2 datasets
largebirds_data <- rbind(ratite, extinct)
largebirds_plot <- cbind (largebirds_data[,1:3], log (largebirds_data[,4:16]))
#Also here setting up a vector of colours you can use to highlight _Genyornis_
#make a vector of just pink
colours <- rep("hotpink", nrow(largebirds_plot))
#make a vector where any species name that has Genyornis is assigned purple
colours[which(largebirds_plot$species == "Genyornis newtoni")] <- "#33cc33"
colours[which(largebirds_plot$species == "Illbandornis lawsoni")] <- "#196619"
colours[which(largebirds_plot$species == "Illbandornis woodburnei")] <- "green"
colours[which(largebirds_plot$species == "Aepyornis maximus")] <- "#ff0000"
colours[which(largebirds_plot$species == "Mullerornis modestus")] <- "#cc0000"
colours[which(largebirds_plot$species == "Dinornis robustus")] <- "#ff6600"
colours[which(largebirds_plot$species == "Dinornis novaezealandiae")] <- "#b34700"
colours[which(largebirds_plot$species == "Pachyornis elephantopus")] <- "#ffc299"
colours[which(largebirds_plot$species == "Struthio camelus")] <- "#191966"
colours[which(largebirds_plot$species == "Dromaius novaehollandiae")] <- "#3366ff"
colours[which(largebirds_plot$species == "Casuarius casuarius")] <- "#3333cc"
#linear model of the femur width vs tibia width in large flightless birds
model3 <- lm(fM.L ~ tbM.L, data=largebirds_plot)
#summary output of the linear model
summary (model3)
min_xB <- sort(largebirds_plot$tbM.L)[1]
max_xB <- sort(largebirds_plot$tbM.L, decreasing = TRUE)[1]
#make dummy sequence of x for intervals.
newxB <- seq(min_xB-1,max_xB+1,by = 0.05)
#plot confidence intervals
#This only works if the data are already logged. Not my preference but hey.
conf_intervalB <- predict(model3, newdata=data.frame(tbM.L = newxB), interval="prediction", level = 0.95)
plot (largebirds_plot$fM.L ~ largebirds_plot$tbM.L,
pch=19, col=colours); abline(model3, col="black" )
lines(newxB, conf_intervalB[,2], col="blue", lty=2)
lines(newxB, conf_intervalB[,3], col="blue", lty=2)
#fill in area between regression line and confidence interval - very pretty but then you have to re-plot the points
polygon(c(rev(newxB), newxB), c(rev(conf_intervalB[ ,3]), conf_intervalB[ ,2]), density = 25, col = 'grey', border = NA)
points(largebirds_plot$fM.L ~ largebirds_plot$tbM.L,
pch=19, col=colours); abline(model3, col="black" )
lines(newxB, conf_intervalB[,2], col="blue", lty=2)
lines(newxB, conf_intervalB[,3], col="blue", lty=2)
#make a vector of just pink
colours <- rep("hotpink", nrow(data_plot))
#make a vector where any species name that has Genyornis is assigned purple
colours[which(data_plot$species == "Genyornis newtoni")] <- "#33cc33"
colours[which(data_plot$species == "Illbandornis lawsoni")] <- "#196619"
colours[which(data_plot$species == "Illbandornis woodburnei")] <- "green"
colours[which(data_plot$species == "Aepyornis maximus")] <- "#ff0000"
colours[which(data_plot$species == "Aepyornis hildebrandti")] <- "red"
colours[which(data_plot$species == "Mullerornis modestus")] <- "#cc0000"
colours[which(data_plot$species == "Dinornis robustus")] <- "#ff6600"
colours[which(data_plot$species == "Dinornis novaezealandiae")] <- "#b34700"
colours[which(data_plot$species == "Pachyornis elephantopus")] <- "#ffc299"
colours[which(data_plot$species == "Struthio camelus")] <- "#191966"
colours[which(data_plot$species == "Dromaius novaehollandiae")] <- "#3366ff"
colours[which(data_plot$species == "Casuarius casuarius")] <- "#3333cc"
colours[which(data_plot$species == "Leipoa ocellata")] <- "#9900cc"
colours[which(data_plot$species == "Alectura lathami")] <- "#800080"
colours[which(data_plot$species == "Cereopsis novaehollandiae")] <- "#ff00ff"
colours[which(data_plot$species == "Anseranas semipalmata")] <- "#ff0055"
#getting a model for predicting CIs
modelFLW <- lm(fM.L ~ fL, data=data_plot)
summary(modelFLW)
#For the interval estimate to work, we need to find the smallest and largest values of x. All this is in https://stackoverflow.com/questions/46459620/plotting-a-95-confidence-interval-for-a-lm-object
#But X in this case has NAs so we're here finding the lowest non-NA value by sorting from smallest to largest and taking the first value
min_xW <- sort(data_plot$fL)[1]
max_xW <- sort(data_plot$fL, decreasing = TRUE)[1]
#make dummy sequence of x for intervals.
newxW <- seq(min_xW-1,max_xW+1,by = 0.05 )
#plot confidence intervals
#This only works if the data are already logged. Not my preference but hey.
conf_intervalW <- predict(modelFLW, newdata=data.frame(fL = newxW), interval="prediction", level = 0.95)
plot(data_plot$fM.L ~ data_plot$fL,
pch=19, col=colours); abline(modelFLW, col="black" )
lines(newxW, conf_intervalW [,2], col="blue", lty=2)
lines(newxW, conf_intervalW [,3], col="blue", lty=2)
#fill in area between regression line and confidence interval - very pretty but then you have to re-plot the points
polygon(c(rev(newxW), newxW), c(rev(conf_intervalW [ ,3]), conf_intervalW[ ,2]),density = 25, col = 'grey', border = NA)
points(data_plot$fM.L ~ data_plot$fL,
pch=19, col=colours); abline(modelFLW, col="black" )
lines(newxW, conf_intervalW [,2], col="blue", lty=2)
lines(newxW, conf_intervalW [,3], col="blue", lty=2)
#text to data points
#text(log(data$fL) ~ log(data$fM.L), label=data$species)
#getting a model for predicting CIs
modelFTL <- lm(fL ~ tbL, data=data_plot)
summary(modelFTL)
#For the interval estimate to work, we need to find the smallest and largest values of x. All this is in https://stackoverflow.com/questions/46459620/plotting-a-95-confidence-interval-for-a-lm-object
#But X in this case has NAs so we're here finding the lowest non-NA value by sorting from smallest to largest and taking the first value
min_xL <- sort(data_plot$tbL)[1]
max_xL <- sort(data_plot$tbL, decreasing = TRUE)[1]
#make dummy sequence of x for intervals.
newxL <- seq(min_xL-1,max_xL+1,by = 0.05 )
#plot confidence intervals
#This only works if the data are already logged. Not my preference but hey.
conf_intervalL <- predict(modelFTL, newdata=data.frame(tbL = newxL), interval="prediction",    level = 0.95)
plot(data_plot$fL ~ data_plot$tbL,
pch=19, col=colours); abline(modelFTL, col="black" )
lines(newxL, conf_intervalL [,2], col="blue", lty=2)
lines(newxL, conf_intervalL [,3], col="blue", lty=2)
#text((data_plot$fL ~ data_plot$tbL), label=data$species)
#fill in area between regression line and confidence interval - very pretty but then you have to re-plot the points
polygon(c(rev(newxL), newxL), c(rev(conf_intervalL [ ,3]), conf_intervalL[ ,2]), density = 25, col = 'grey', border = NA)
points(data_plot$fL ~ data_plot$tbL,
pch=19, col=colours); abline(modelFTL, col="black" )
lines(newxL, conf_intervalL [,2], col="blue", lty=2)
lines(newxL, conf_intervalL [,3], col="blue", lty=2)
#mean lengths of the femur, tibiotarsus, and tarsometatarsus
#Aepyornis hildebrandti is excluded as Hasnford and Turvery have no tibiotarsi measurements
mean_lengths <- read.csv (file = "../Data/Raw/mean_lengths_2.csv")
#making sure that the bone is a factor so that it stacks correctly in the plot
mean_lengths$bone <- factor(mean_lengths$bone, levels = c("Femur", "Tibiotarsus", "Tarsometatarsus"))
#this makes the species labels along the x axis run in this order
mean_lengths$species <- factor (mean_lengths$species, levels = c("Struthio camelus", "Casuarius casuarius",	"Dromaius novaehollandiae",	"Pachyornis elephantopus",	"Dinornis novaezealandiae",	"Dinornis robustus",	"Mullerornis modestus",	"Aepyornis maximus",	"Alectura lathami",	"Leipoa ocellata",	"Anseranas semipalmata",	"Cereopsis novaehollandiae",	"Dinornis stirtoni", "Illbandornis woodburnei",	"Illbandornis lawsoni",	"Genyornis newtoni"))
#code for the bar plot
ggplot(mean_lengths, aes(fill = bone, y = mean_length, x = species)) +
geom_bar(position="fill", stat="identity") +
#labels for the x, y axis, plot title, and legend
labs(title = "Mean Lengths of Bones by Species",
x = "Species",
y = "Total pecentage of hindlimb legnth ",
fill = "Hindlimb bone") +
#colours for the hindlimb bones and order that they should plot as
scale_fill_manual(values = c("Femur" = "#e31a1c", "Tibiotarsus" = "#1f78b4", "Tarsometatarsus" = "#33a02c")) +
#y axis should be in 10% increments instead of the standaard 25%
scale_y_continuous(breaks = seq(0, 1, by = 0.1),
labels = function(x) paste0(x * 100, "%")) +
#tilts the x axis labels vertical
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
#making a seperate dataset w/o moas
meanL_noM <- mean_lengths [-c(10:18),]
#making sure that the bone is a factor so that it stacks correctly in the plot
meanL_noM$bone <- factor(meanL_noM$bone, levels = c("Femur", "Tibiotarsus", "Tarsometatarsus"))
#this makes the species labels along the x axis run in this order
meanL_noM$species <- factor (meanL_noM$species, levels = c("Struthio camelus", "Casuarius casuarius",	"Dromaius novaehollandiae",	"Mullerornis modestus",	"Aepyornis maximus",	"Alectura lathami",	"Leipoa ocellata",	"Anseranas semipalmata",	"Cereopsis novaehollandiae",	"Dinornis stirtoni", "Illbandornis woodburnei",	"Illbandornis lawsoni",	"Genyornis newtoni"))
#code for the bar plot
ggplot(meanL_noM, aes(fill = bone, y = mean_length, x = species)) +
geom_bar(position="fill", stat="identity") +
#labels for the x, y axis, plot title, and legend
labs(title = "Mean Lengths of Bones by Species",
x = "Species",
y = "Total pecentage of hindlimb legnth ",
fill = "Hindlimb bone") +
#colours for the hindlimb bones and order that they should plot as
scale_fill_manual(values = c("Femur" = "#e31a1c", "Tibiotarsus" = "#1f78b4", "Tarsometatarsus" = "#33a02c")) +
#y axis should be in 10% increments instead of the standaard 25%
scale_y_continuous(breaks = seq(0, 1, by = 0.1),
labels = function(x) paste0(x * 100, "%")) +
#tilts the x axis labels vertical
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```{r ternary plot for hindlimb proportions}
longbone_length <- read.csv (file = "../Data/Raw/longbone_lengths.csv")
library("ggtern")
ggtern(data=longbone_length, aes (x = fL, y = tbL, z = tmtL)) +
geom_point()
#trying to run a reduced major axis regression
data2_rma <- lmodel2((log(fM.L)~log(tbM.L)), data=data2, "relative", "relative", nperm=99)
#trying to run a reduced major axis regression
data2_rma <- lmodel2((log(fM.L)~log(tbM.L)), data=data2, "relative", "relative", nperm=99)
#trying to run a reduced major axis regression
data2_rma <- lmodel2((log(fM.L)~log(tbM.L)), data=data2, "relative", "relative", nperm=99)
install.packages("lmodel2")
library(lmodel2)
library(lmodel2)
#trying to run a reduced major axis regression
data2_rma <- lmodel2((log(fM.L)~log(tbM.L)), data=data2, "relative", "relative", nperm=99)
summary(data2_rma)
plot(data2_rma, "SMA")
plot(data2_rma, "RMA")
View(datanoD_plot)
#trying to run a reduced major axis regression
data2_rma <- lmodel2(fM.L~tbM.L, data=data_plot2, "relative", "relative", nperm=99)
summary(data2_rma)
#very unpretty plots but a starting point
plot(data2_rma, "SMA")
plot(data2_rma, "RMA")
plot(data2_rma,
xlim=c(1.6,4.5),
ylim=c(1.7,4.5),
pch=19, col=colours)
lines(newx, conf_interval[,2], col="blue", lty=2)
#trying to run a reduced major axis regression
#this creates the model that will hopefully work when creating CIs
data2_rma <- lmodel2(fM.L~tbM.L, data=data_plot2, "relative", "relative", nperm=99)
View(data2_rma)
View(model)
View(model1)
ggplot(data_plot2$fM.L~data_plot2$tbM.L) +
geom_point (aes(data_plot2$fM.L, data_plot2$tbM.L)) +
geom_abline (data2_rma)
ggplot(data_plot2$fM.L~data_plot2$tbM.L) +
geom_point (aes(data_plot2$fM.L, data_plot2$tbM.L)) +
geom_abline (data2_rma)
rlang::last_trace()
reg <- data2_rma$regression.results
View(reg)
names(reg) <- c("method", "intercept", "slope", "angle", "p-value")
ggplot(data_plot2$fM.L~data_plot2$tbM.L) +
geom_point (aes(data_plot2$fM.L, data_plot2$tbM.L)) +
geom_abline (data = reg, aes(intercept = intercept, slope = slope, colour = method))
#getting a model for predicting CIs
modelFW <- lm(fM.L ~ fCr.Ca, data=data_plot)
summary(modelW)
#getting a model for predicting CIs
modelFW <- lm(fM.L ~ fCr.Ca, data=data_plot)
summary(modelW)
#But X in this case has NAs so we're here finding the lowest non-NA value by sorting from smallest to largest and taking the first value
min_xW <- sort(data_plot$fCr.Ca)[1]
max_xW <- sort(data_plot$fCr.Ca, decreasing = TRUE)[1]
#make dummy sequence of x for intervals.
newxW <- seq(min_xW-1,max_xW+1,by = 0.05 )
#This only works if the data are already logged. Not my preference but hey.
conf_intervalW <- modelFW(modelFLW, newdata=data.frame(fCr.Ca = newxW), interval="prediction", level = 0.95)
plot(data=data_plot, fM.L ~ fCr.Ca
pch=19, col=colours); abline(modelFW, col="black" )
#This only works if the data are already logged. Not my preference but hey.
conf_intervalFW <- modelFW(modelFW, newdata=data.frame(fCr.Ca = newxW), interval="prediction", level = 0.95)
#getting a model for predicting CIs
modelFW <- lm(fM.L ~ fCr.Ca, data=data_plot)
summary(modelW)
#But X in this case has NAs so we're here finding the lowest non-NA value by sorting from smallest to largest and taking the first value
min_xW <- sort(data_plot$fCr.Ca)[1]
max_xW <- sort(data_plot$fCr.Ca, decreasing = TRUE)[1]
#getting a model for predicting CIs
modelFW <- lm(fM.L ~ fCr.Ca, data=data_plot)
summary(modelFW)
#But X in this case has NAs so we're here finding the lowest non-NA value by sorting from smallest to largest and taking the first value
min_xFW <- sort(data_plot$fCr.Ca)[1]
max_xFW <- sort(data_plot$fCr.Ca, decreasing = TRUE)[1]
#make dummy sequence of x for intervals.
newxFW <- seq(min_xFW-1,max_xFW+1,by = 0.05 )
#This only works if the data are already logged. Not my preference but hey.
conf_intervalFW <- modelFW(modelFW, newdata=data.frame(fCr.Ca = newxW), interval="prediction", level = 0.95)
#This only works if the data are already logged. Not my preference but hey.
conf_intervalFW <- predict(modelFW, newdata=data.frame(fCr.Ca = newxW), interval="prediction", level = 0.95)
plot(data=data_plot, fM.L ~ fCr.Ca
pch=19, col=colours); abline(modelFW, col="black" )
plot(data_plot$fM.L ~ data_plot$fCr.Ca
pch=19, col=colours); abline(modelFW, col="black" )
plot(data=data_plot, fM.L ~ fCr.Ca,
pch=19, col=colours); abline(modelFW, col="black" )
lines(newxW, conf_intervalW [,2], col="blue", lty=2)
lines(newxW, conf_intervalW [,3], col="blue", lty=2)
#fill in area between regression line and confidence interval - very pretty but then you have to re-plot the points
polygon(c(rev(newxW), newxW), c(rev(conf_intervalW [ ,3]), conf_intervalW[ ,2]),density = 25, col = 'grey', border = NA)
#fill in area between regression line and confidence interval - very pretty but then you have to re-plot the points
polygon(c(rev(newxFW), newxFW), c(rev(conf_intervalFW [ ,3]), conf_intervalFW[ ,2]),density = 25, col = 'grey', border = NA)
points(data=data_plot, fM.L ~ fCr.Ca,
pch=19, col=colours); abline(modelFLW, col="black" )
lines(newxFW, conf_intervalFW [,2], col="blue", lty=2)
lines(newxFW, conf_intervalFW [,3], col="blue", lty=2)
#getting a model for predicting CIs
modelFW <- lm(fM.L ~ fCr.Ca, data=data_plot)
summary(modelFW)
#For the interval estimate to work, we need to find the smallest and largest values of x. All this is in https://stackoverflow.com/questions/46459620/plotting-a-95-confidence-interval-for-a-lm-object
#But X in this case has NAs so we're here finding the lowest non-NA value by sorting from smallest to largest and taking the first value
min_xFW <- sort(data_plot$fCr.Ca)[1]
max_xFW <- sort(data_plot$fCr.Ca, decreasing = TRUE)[1]
#make dummy sequence of x for intervals.
newxFW <- seq(min_xFW-1,max_xFW+1,by = 0.05 )
#plot confidence intervals
#This only works if the data are already logged. Not my preference but hey.
conf_intervalFW <- predict(modelFW, newdata=data.frame(fCr.Ca = newxW), interval="prediction", level = 0.95)
plot(data=data_plot, fM.L ~ fCr.Ca,
pch=19, col=colours); abline(modelFW, col="black" )
lines(newxFW, conf_intervalFW [,2], col="blue", lty=2)
lines(newxFW, conf_intervalFW [,3], col="blue", lty=2)
#fill in area between regression line and confidence interval - very pretty but then you have to re-plot the points
polygon(c(rev(newxFW), newxFW), c(rev(conf_intervalFW [ ,3]), conf_intervalFW[ ,2]),density = 25, col = 'grey', border = NA)
plot(data=data_plot, fM.L ~ fCr.Ca,
pch=19, col=colours); abline(modelFW, col="black" )
lines(newxFW, conf_intervalFW [,2], col="blue", lty=2)
lines(newxFW, conf_intervalFW [,3], col="blue", lty=2)
#fill in area between regression line and confidence interval - very pretty but then you have to re-plot the points
polygon(c(rev(newxFW), newxFW), c(rev(conf_intervalFW [ ,3]), conf_intervalFW[ ,2]),density = 25, col = 'grey', border = NA)
plot(data=data_plot, fM.L ~ fCr.Ca,
pch=19, col=colours); abline(modelFW, col="black" )
lines(newxFW, conf_intervalFW [,2], col="blue", lty=2)
#getting a model for predicting CIs
modelFLW <- lm(fM.L ~ fL, data=data_plot)
summary(modelFLW)
#But X in this case has NAs so we're here finding the lowest non-NA value by sorting from smallest to largest and taking the first value
min_xW <- sort(data_plot$fL)[1]
max_xW <- sort(data_plot$fL, decreasing = TRUE)[1]
#make dummy sequence of x for intervals.
newxW <- seq(min_xW-1,max_xW+1,by = 0.05 )
#This only works if the data are already logged. Not my preference but hey.
conf_intervalW <- predict(modelFLW, newdata=data.frame(fL = newxW), interval="prediction", level = 0.95)
plot(data_plot$fM.L ~ data_plot$fL,
pch=19, col=colours); abline(modelFLW, col="black" )
lines(newxW, conf_intervalW [,2], col="blue", lty=2)
lines(newxW, conf_intervalW [,3], col="blue", lty=2)
#fill in area between regression line and confidence interval - very pretty but then you have to re-plot the points
polygon(c(rev(newxW), newxW), c(rev(conf_intervalW [ ,3]), conf_intervalW[ ,2]),density = 25, col = 'grey', border = NA)
points(data_plot$fM.L ~ data_plot$fL,
pch=19, col=colours); abline(modelFLW, col="black" )
lines(newxW, conf_intervalW [,2], col="blue", lty=2)
lines(newxW, conf_intervalW [,3], col="blue", lty=2)
#getting a model for predicting CIs
modelFW <- lm(fM.L ~ fCr.Ca, data=data_plot)
summary(modelFW)
#But X in this case has NAs so we're here finding the lowest non-NA value by sorting from smallest to largest and taking the first value
min_xFW <- sort(data_plot$fCr.Ca)[1]
max_xFW <- sort(data_plot$fCr.Ca, decreasing = TRUE)[1]
#make dummy sequence of x for intervals.
newxFW <- seq(min_xFW-1,max_xFW+1,by = 0.05 )
#This only works if the data are already logged. Not my preference but hey.
conf_intervalFW <- predict(modelFW, newdata=data.frame(fCr.Ca = newxW), interval="prediction", level = 0.95)
plot(data=data_plot, fM.L ~ fCr.Ca,
pch=19, col=colours); abline(modelFW, col="black" )
lines(newxFW, conf_intervalFW [,2], col="blue", lty=2)
lines(newxFW, conf_intervalFW [,3], col="blue", lty=2)
#But X in this case has NAs so we're here finding the lowest non-NA value by sorting from smallest to largest and taking the first value
min_xFW <- sort(data_plot$fCr.Ca)[1]
max_xFW <- sort(data_plot$fCr.Ca, decreasing = TRUE)[1]
#make dummy sequence of x for intervals.
newxFW <- seq(min_xFW-1,max_xFW+1,by = 0.05 )
#This only works if the data are already logged. Not my preference but hey.
conf_intervalFW <- predict(modelFW, newdata=data.frame(fCr.Ca = newxW), interval="prediction", level = 0.95)
plot(data=data_plot, fM.L ~ fCr.Ca,
pch=19, col=colours); abline(modelFW, col="black" )
lines(newxFW, conf_intervalFW [,2], col="blue", lty=2)
lines(newxFW, conf_intervalFW [,3], col="blue", lty=2)
#fill in area between regression line and confidence interval - very pretty but then you have to re-plot the points
polygon(c(rev(newxFW), newxFW), c(rev(conf_intervalFW [ ,3]), conf_intervalFW[ ,2]),density = 25, col = 'grey', border = NA)
points(data=data_plot, fM.L ~ fCr.Ca,
pch=19, col=colours); abline(modelFLW, col="black" )
lines(newxW, conf_intervalW [,2], col="blue", lty=2)
#fill in area between regression line and confidence interval - very pretty but then you have to re-plot the points
polygon(c(rev(newxFW), newxFW), c(rev(conf_intervalFW [ ,3]), conf_intervalFW[ ,2]),density = 25, col = 'grey', border = NA)
